---
layout: "base.njk"
title: "The History of UI Library"
date: 2024-10-21
wip: true
---

오늘날 웹 생태계에는 수많은 UI 라이브러리가 존재하지만, 2000년대 초반까지만 해도 이러한 도구들은 찾아보기 어려웠습니다.
당시 웹 개발자들은 버튼, 폼, 레이아웃 같은 기본적인 UI 요소까지 모두 직접 구현해야 했고, 그 결과 세련된 웹사이트를 만드는 데 많은 시간과 비용이 들었습니다.

UI 라이브러리의 등장은 이러한 문제를 해결하는 데 큰 전환점이 되었습니다.
이제 개발자들은 디자이너의 도움 없이도 완성도 높은 웹사이트를 빠르게 구축할 수 있게 되었고, 그 결과 개발 생산성이 크게 향상되었습니다.
또한, 기업들은 여러 서비스에 일관된 디자인 스타일을 유지할 수 있게 되어 브랜드 이미지와 정체성을 강화할 수 있었습니다. 일관성 있는 디자인은 기업에 중요한 경쟁 요소로 자리 잡기 시작했습니다.

이러한 흐름 속에서 많은 기업들은 단순한 UI 라이브러리 사용을 넘어 타이포그래피, 색상 팔레트, 간격 규칙, 애니메이션 스타일 등 전체적인 시각 언어와 사용 원칙을 체계화한 디자인 시스템이라는 개념을 도입하기에 이르렀습니다.

이렇게 현대 웹 개발의 생산성을 높이고 디자인 시스템이라는 개념 등장에 중요한 역할을 한 UI 라이브러리가 어떻게 발전해오고 있는지 1세대에서 4세대로 구분하여 살펴보겠습니다.

## 1세대: Bootstrap의 탄생

Bootstrap은 UI 라이브러리 역사에서 중요한 전환점이 된 도구입니다. 이전에도 UI 라이브러리가 있었지만, Bootstrap은 개발자들에게 그 필요성과 가치를 널리 알리는 데 큰 역할을 했습니다.

Twitter의 개발자 Mark Otto와 Jacob Thornton이 내부 프로젝트에서 빠른 프로토타입 제작을 위해 개발한 이 도구는, 이후 오픈소스로 공개되며 웹 개발 커뮤니티에서 폭발적인 반응을 얻었습니다.

Bootstrap은 `.btn`, `.card`와 같은 미리 정의된 CSS 클래스를 제공하여, 개발자가 HTML에 간단히 적용하는 것만으로 일관된 디자인의 UI를 손쉽게 구현할 수 있게 했습니다.

Bootstrap의 성공을 바탕으로 다양한 테마와 스타일을 적용한 UI 라이브러리들이 연이어 등장하며, 웹 개발의 새로운 흐름을 형성했습니다.

- Bootstrap 첫번째 릴리즈 2011/8
- Semantic UI 2013/9/26
- Pure CSS 2013/9/10

## 2세대: 컴포넌트형 UI 라이브러리의 등장

1세대 UI 라이브러리들은 class 속성을 사용해 스타일을 정의했습니다. 그러나 이 방식은 HTML에 여러 태그와 클래스명을 반복적으로 추가해야 했고, 프로젝트가 커질수록 유지보수가 어려워졌습니다.

이후 Vue, React, Angular 같은 프레임워크들이 등장하며 컴포넌트 기반 개발이 표준으로 자리 잡았습니다. 개발자들은 UI를 작은 컴포넌트 단위로 분리해 재사용할 수 있게 되었고, 각 컴포넌트는 자체적인 상태와 로직을 관리하도록 구현되었습니다. 이러한 변화에 따라 UI 라이브러리들도 `<Button>`, `<Alert>`처럼 컴포넌트 형태로 제공되기 시작했습니다.

컴포넌트형 UI 라이브러리는 긴 HTML과 반복적인 class 작성의 부담을 덜어주었고, 재사용성과 유지보수성을 크게 향상시켰습니다. 또한, 코드 구조가 더 직관적이 되어 개발 생산성 역시 높아졌습니다.

- 2세대
- Material UI 첫번째 릴리즈 2014/11/06
- Element UI 2016/9/4
- Chakara UI UI 2019/9/7

## 3세대: 커스터마이징의 니즈 증가와 Tailwind CSS의 등장

1세대와 2세대 UI 라이브러리는 디자인 경험이 부족한 개발자들이 빠르게 세련된 웹 사이트를 만들 수 있도록 도와주며, 웹 개발의 생산성을 크게 높였습니다. 이러한 라이브러리들은 웹 개발의 필수 요소로 자리 잡았지만, 각 라이브러리가 정의한 고유한 스타일로 인해 디자이너나 개발자가 원하는 다양한 스타일을 적용하는 데 제약이 있었습니다. 시간이 지나면서 더 자유로운 커스터마이징을 원하는 수요가 늘어나기 시작했고, 이를 충족시키기 위해 커스터마이징이 좀 더 쉽게 할 수 있는 UI 라이브러리들이 등장했습니다.

### 컴포넌트형

2세대 컴포넌트형 UI 라이브러리는 기능과 스타일이 강하게 결합되어 있어 커스터마이징이 어려웠습니다. 컴포넌트의 스타일을 변경하려면 라이브러리 소스 코드 자체를 수정해야 되는 어려움이 있었습니다.

이 문제를 해결하기 위해 등장한 것이 Headless 스타일의 UI 라이브러리 입니다. Headless UI 라이브러리는 컴포넌트의 기능만을 제공하고, 스타일은 개발자가 직접 정의할 수 있도록 만들어졌습니다. 이를 통해 개발자는 컴포넌트의 기능을 유지하면서도 자유롭게 스타일을 커스터마이징할 수 있게 되었습니다. 대표적인 예로 headless UI와 radix UI가 있습니다.

- headlessui 2020/9/24
- radix ui  2021/3/4

### Tailwind CSS와 유틸리티 클래스 기반 스타일링

이때 마침 Tailwindcss의 인기가 급상승하게 되면서 Tailwindcss를 이용해 스타일링을 하는 방식의 UI 라이브러리도 등장했습니다.

Headless UI의 유연함에 맞추어 등장한 또 다른 흐름이 Tailwind CSS를 이용한 스타일링 방식입니다. 이는 1세대 Bootstrap처럼 class 속성으로 스타일을 정의하는 방식을 따르지만, 기본 CSS 대신 Tailwind CSS의 유틸리티 클래스에 최적화된 접근을 사용합니다. 개발자들은 CSS를 직접 작성하지 않고 필요한 스타일을 클래스로 빠르게 조합할 수 있습니다.

- Daisy UI v1 2021/5/22
- Versoly-ui 2022/4/15

## 4세대: 코드베이스에 설치하는 방식의 등장

2세대 UI 라이브러리는 특정 라이브러리에 기능과 스타일링이 전부된 컴포넌트를 사용하는 방식이었지만, 커스터마이징이 제한적이라는 단점이 있었습니다. 이를 보완한 3세대 UI 라이브러리는 기능만 제공하고 스타일링을 개발자에게 맡기는 방식으로 커스터마이징 자유도가 높아졌으나, 개발자가 직접 모든 스타일을 관리해야 하는 단점이 존재했습니다.

이러한 문제를 해결하기 위해 shadcn/ui가 등장했습니다. shadcn/ui의 가장 큰 특징은 특정 UI 라이브러리에 종속되지 다양한 곳에서 필요한 UI 컴포넌트를 사용해 거기에 shadcn/ui 테마 스타일링을 한 코드를 제공한다는 점입니다. 그리고 전통적으로 UI 라이브러리를 node_moduels에 설치하는 대신, 프로젝트 코드베이스에 shadcn/ui 테마가 적용된 컴포넌트 코드를 직접 복사해서 사용하는 구조를 취합니다. 이를 통해 개발자는 컴포넌트의 스타일과 기능을 자유롭게 조정할 수 있으며, Tailwind CSS를 기반으로 스타일을 작성해 Tailwind에도 굉장히 친화적입니다.
hadcn/ui는 주로 Radix UI의 컴포넌트를 활용하지만, 특정 컴포넌트에 얽매이지 않고 다른 라이브러리와도 유연하게 혼합할 수 있습니다.

Shadcn/ui는 단순히 컴포넌트를 제공하는 것에 그치지 않고, CLI 도구를 통해 개발 경험(DX)을 크게 향상시킵니다. 이 CLI를 사용하면 원하는 컴포넌트를 프로젝트에 쉽게 설치하고, 테마와 Tailwind 설정을 자동으로 관리할 수 있습니다. 복잡한 의존성 관리나 설정 작업 없이, 필요한 컴포넌트를 빠르게 추가해 사용할 수 있는 점이 큰 장점입니다.

- 3세대 (Tailwind)
- shadcn 2023/3/9